// Generated by CoffeeScript 1.6.3
(function() {
  var Arrow, BackGround, Border, Break, Canvas, EventHandler, HEIGHT, OFFSET, Parser, StatusBar, Unit, WIDTH, Wall, Websocket, World, emit, getCanvas, getRatio, main, setRatio;

  Arrow = (function() {
    var COLOR_ARROW, CYCLE_COUNT, HEIGHT, OFFSET, SIDE_LEFT, SIDE_RIGHT, V_FAST, V_MIDDLE, V_SLOW, WIDTH;

    COLOR_ARROW = 'RGBA(464, 224, 126, 0.7)';

    WIDTH = 200;

    HEIGHT = 20;

    SIDE_LEFT = 0;

    SIDE_RIGHT = 1;

    OFFSET = 500;

    V_SLOW = 4;

    V_MIDDLE = 5;

    V_FAST = 7;

    CYCLE_COUNT = 800;

    function Arrow(side, world) {
      this.side = side;
      this.world = world;
      this.position = 0;
      this.v = V_MIDDLE;
      this.cycle = 0;
      this.offset = 0;
      this.is_shooting = false;
      this.is_shooting_back = false;
      this.protecting_section_index = 0;
    }

    Arrow.prototype.get_offset = function() {
      if (this.side === SIDE_LEFT) {
        return this.offset - OFFSET;
      }
      if (this.side === SIDE_RIGHT) {
        return this.offset + OFFSET;
      }
    };

    Arrow.prototype.set_position = function(position) {
      return this.position = position;
    };

    Arrow.prototype.get_position = function() {
      return this.position;
    };

    Arrow.prototype.get_half_heigh = function() {
      return HEIGHT / 2;
    };

    Arrow.prototype.shoot = function() {
      var index;
      index = this.world.attackable_index(this);
      if (index !== 0 && index === this.protecting_section_index) {
        return;
      }
      return this.is_shooting = true;
    };

    Arrow.prototype.next_volocity = function() {
      var sign, v;
      v = Math.abs(this.v);
      if (v === 0) {
        return this.last_volocity;
      }
      sign = this.v / v;
      if (v === V_MIDDLE) {
        return sign * V_FAST;
      }
      if (v === V_FAST) {
        return sign * V_SLOW;
      }
      if (v === V_SLOW) {
        return sign * V_MIDDLE;
      }
    };

    Arrow.prototype.is_hit = function() {
      var d, index, offset;
      offset = 0;
      index = this.world.attackable_index(this);
      if (index !== 0) {
        offset = this.world.break_offset(index);
      }
      if (this.side === SIDE_RIGHT) {
        offset = -offset;
      }
      d = offset + this.world.half_width() - 2 * WIDTH - 150;
      if (this.side === SIDE_LEFT) {
        return this.offset >= d;
      }
      if (this.side === SIDE_RIGHT) {
        return this.offset <= -d;
      }
    };

    Arrow.prototype.shoot_forward = function() {
      var index, offset, v;
      v = Math.abs(this.v);
      if (this.side === SIDE_RIGHT) {
        v = -v;
      }
      this.offset += v;
      if (this.is_hit()) {
        this.is_shooting_back = true;
        index = this.world.attackable_index(this);
        if (index !== 0) {
          return offset = this.world.move_break(index, this.side);
        }
      }
    };

    Arrow.prototype.stop = function() {
      return this.halt = true;
    };

    Arrow.prototype.shoot_back = function() {
      var v;
      v = Math.abs(this.v);
      if (this.side === SIDE_LEFT) {
        v = -v;
      }
      this.offset += v;
      if (this.offset <= 0 && this.side === SIDE_LEFT || this.offset >= 0 && this.side === SIDE_RIGHT) {
        this.is_shooting_back = false;
        this.is_shooting = false;
        return this.protecting_section_index = this.world.attackable_index(this);
      }
    };

    Arrow.prototype.roaming = function() {
      var h;
      if (this.halt) {
        return;
      }
      if (this.world.attackable_index(this) === 0) {
        this.protecting_section_index = 0;
      }
      this.position += this.v;
      h = this.world.half_height();
      if (this.position >= h) {
        this.v = -this.v;
      }
      if (this.position <= -h) {
        return this.v = -this.v;
      }
    };

    Arrow.prototype.volocity_change = function() {
      this.cycle += 1;
      if (this.cycle === CYCLE_COUNT) {
        this.v = this.next_volocity();
        return this.cycle = 0;
      }
    };

    Arrow.prototype.run = function() {
      if (this.is_shooting_back) {
        this.shoot_back();
      } else if (this.is_shooting) {
        this.shoot_forward();
      } else {
        this.roaming();
      }
      return this.volocity_change();
    };

    Arrow.prototype.render = function(canvas) {
      var offset;
      this.run();
      offset = this.get_offset();
      return canvas.fillRect(COLOR_ARROW, {
        x: offset - WIDTH / 2,
        y: this.position - HEIGHT / 2,
        w: WIDTH,
        h: HEIGHT
      });
    };

    return Arrow;

  })();

  BackGround = (function() {
    var COLOR_ATTACK, COLOR_BORDER, COLOR_LINE, HEIGHT, WALL_WIDTH, WIDTH;

    WIDTH = 1600;

    HEIGHT = 800;

    WALL_WIDTH = 150;

    COLOR_BORDER = 'RGB(100, 0, 240)';

    COLOR_LINE = 'RGB(100, 0, 240)';

    COLOR_ATTACK = 'RGBA(264, 224, 126, 0.4)';

    function BackGround(size) {
      this.size = size;
      this.border = new Border;
      this.wall = new Wall(HEIGHT, WALL_WIDTH);
    }

    BackGround.prototype.radius = function() {
      return WIDTH / this.size / 2.0 - 3;
    };

    BackGround.prototype.point2pos = function(point) {
      var base_x, base_y, h, heightUnit, ratio, w, widthUnit, x, xx, y, yy;
      ratio = getRatio();
      w = $("#chess-board").width();
      h = $("#chess-board").height();
      base_x = w / 2 - WIDTH / 2 * ratio;
      base_y = h / 2 - HEIGHT / 2 * ratio;
      x = point.x - base_x - WIDTH / 2 * ratio;
      y = point.y - base_y - HEIGHT / 2 * ratio;
      if (x < -WIDTH / 2 * ratio || x > WIDTH / 2 * ratio) {
        return {
          x: -1,
          y: -1
        };
      }
      if (y < -HEIGHT / 2 * ratio || y > HEIGHT / 2 * ratio) {
        return {
          x: -1,
          y: -1
        };
      }
      widthUnit = WIDTH * ratio / this.size;
      heightUnit = HEIGHT * ratio / this.size;
      xx = x / widthUnit + this.size / 2;
      yy = -(y / heightUnit) + this.size / 2;
      return {
        x: Math.floor(xx),
        y: Math.floor(yy)
      };
    };

    BackGround.prototype.position2point = function(pos) {
      var heightUnit, widthUnit, x, y;
      if (pos.x < 0 || pos.x >= this.size || pos.y < 0 || pos.y >= this.size) {
        return {
          x: -1,
          y: -1
        };
      }
      widthUnit = WIDTH / this.size;
      heightUnit = HEIGHT / this.size;
      x = -WIDTH / 2 + pos.x * widthUnit + widthUnit / 2;
      y = -HEIGHT / 2 + pos.y * heightUnit + heightUnit / 2;
      return {
        x: x,
        y: -y
      };
    };

    BackGround.prototype.hight_light_attckable_points = function(ps, canvas) {
      var field, heightUnit, point, pos, widthUnit, _i, _len, _results;
      widthUnit = WIDTH / this.size;
      heightUnit = HEIGHT / this.size;
      _results = [];
      for (_i = 0, _len = ps.length; _i < _len; _i++) {
        pos = ps[_i];
        point = this.position2point(pos);
        field = {
          x: point.x - widthUnit / 2,
          y: point.y - heightUnit / 2,
          w: widthUnit,
          h: heightUnit
        };
        _results.push(canvas.fillRect(COLOR_ATTACK, field));
      }
      return _results;
    };

    BackGround.prototype.render = function(canvas) {
      var heightUnit, i, widthUnit, x1, y1, _i, _ref, _results;
      this.border.render(canvas);
      this.wall.render(canvas);
      return;
      widthUnit = WIDTH / this.size;
      heightUnit = HEIGHT / this.size;
      _results = [];
      for (i = _i = 1, _ref = this.size; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        i = i - this.size / 2;
        x1 = i * widthUnit;
        y1 = i * heightUnit;
        canvas.drawLine(COLOR_BORDER, x1, -HEIGHT / 2, x1, HEIGHT / 2);
        _results.push(canvas.drawLine(COLOR_BORDER, -HEIGHT / 2, y1, HEIGHT / 2, y1));
      }
      return _results;
    };

    return BackGround;

  })();

  Border = (function() {
    var COLOR_ATTACK, COLOR_BORDER, COLOR_LINE, HEIGHT, WIDTH;

    WIDTH = 1600;

    HEIGHT = 800;

    COLOR_BORDER = 'RGB(100, 0, 240)';

    COLOR_LINE = 'RGB(100, 0, 240)';

    COLOR_ATTACK = 'RGBA(264, 224, 126, 0.4)';

    function Border() {}

    Border.prototype.render = function(canvas) {
      return canvas.drawRect(COLOR_BORDER, {
        x: -WIDTH / 2,
        y: -HEIGHT / 2,
        w: WIDTH,
        h: HEIGHT
      });
    };

    return Border;

  })();

  Break = (function() {
    var COLOR_BREAK, DANGER_LEFT, DANGER_LEFT_2, DANGER_LEFT_3, DANGER_MIDDLE, DANGER_RIGHT, DANGER_RIGHT_2, DANGER_RIGHT_3, PUSH_FROM_LEFT, PUSH_FROM_RIGHT;

    COLOR_BREAK = 'RGB(100, 250, 240)';

    PUSH_FROM_LEFT = 0;

    PUSH_FROM_RIGHT = 1;

    DANGER_MIDDLE = 0;

    DANGER_LEFT = -1;

    DANGER_LEFT_2 = -2;

    DANGER_LEFT_3 = -3;

    DANGER_RIGHT = 1;

    DANGER_RIGHT_2 = 2;

    DANGER_RIGHT_3 = 3;

    function Break(height, world, width, position) {
      this.world = world;
      this.height = height;
      this.width = width;
      this.position = position;
      this.danger = DANGER_MIDDLE;
      this.is_falling = false;
    }

    Break.prototype.get_offset = function() {
      var delta;
      delta = 2 * this.width / 3;
      if (this.danger === DANGER_MIDDLE) {
        return 0;
      }
      if (this.danger === DANGER_LEFT) {
        return -1 * delta;
      }
      if (this.danger === DANGER_LEFT_2) {
        return -2 * delta;
      }
      if (this.danger === DANGER_LEFT_3) {
        return -3 * delta;
      }
      if (this.danger === DANGER_RIGHT) {
        return 1 * delta;
      }
      if (this.danger === DANGER_RIGHT_2) {
        return 2 * delta;
      }
      if (this.danger === DANGER_RIGHT_3) {
        return 3 * delta;
      }
    };

    Break.prototype.move = function(side) {
      if (side === PUSH_FROM_LEFT) {
        this.danger += 1;
      } else if (side === PUSH_FROM_RIGHT) {
        this.danger -= 1;
      }
      if (this.danger === DANGER_LEFT_3) {
        this.is_falling = true;
        return this.world.gameover(PUSH_FROM_RIGHT);
      } else if (this.danger === DANGER_RIGHT_3) {
        this.is_falling = true;
        return this.world.gameover(PUSH_FROM_LEFT);
      }
    };

    Break.prototype.render = function(canvas) {
      var field, offset;
      if (this.is_falling) {
        if (this.danger === DANGER_LEFT_3 || this.danger === DANGER_RIGHT_3) {
          this.position += 5;
        }
        if (this.position >= this.world.half_height() - 50) {
          this.is_falling = false;
        }
      }
      offset = this.get_offset();
      field = {
        x: offset - this.width,
        y: this.position - this.height / 2,
        w: this.width * 2,
        h: this.height
      };
      return canvas.fillRect(COLOR_BREAK, field);
    };

    return Break;

  })();

  Canvas = function(ctx, w, h) {
    this.ctx = ctx;
    this.w = w;
    return this.h = h;
  };

  Canvas.prototype.fillRect = function(color, rect) {
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawRect = function(color, rect) {
    this.ctx.strokeStyle = color;
    return this.ctx.strokeRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawLine = function(color, sx, sy, ex, ey) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(this.xscreen(sx), this.yscreen(sy));
    this.ctx.lineTo(this.xscreen(ex), this.yscreen(ey));
    return this.ctx.stroke();
  };

  Canvas.prototype.drawArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.stroke();
  };

  Canvas.prototype.fillArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.fill();
  };

  Canvas.prototype.drawCircle = function(color, x, y, r) {
    return this.drawArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.fillCircle = function(color, x, y, r) {
    return this.fillArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.drawText = function(color, font, text, x, y) {
    this.ctx.fillStyle = color;
    this.ctx.font = font;
    x = x - this.ctx.measureText(text).width / 2;
    return this.ctx.fillText(text, this.xscreen(x), this.yscreen(y));
  };

  Canvas.prototype.clear = function() {
    return this.ctx.clearRect(0, 0, this.w, this.h);
  };

  Canvas.prototype.xscreen = function(x) {
    return x + this.w / 2;
  };

  Canvas.prototype.yscreen = function(y) {
    return y + this.h / 2;
  };

  EventHandler = (function() {
    function EventHandler(world) {
      var listener;
      $("#chess-board").click(function(e) {
        var clicked_point, pos;
        clicked_point = {
          x: e.offsetX,
          y: e.offsetY
        };
        pos = world.board.point2pos(clicked_point);
        return world.select(pos);
      });
      $("#chess-board").mousemove(function(e) {
        var clicked_point, pos;
        clicked_point = {
          x: e.offsetX,
          y: e.offsetY
        };
        pos = world.board.point2pos(clicked_point);
        return world.hover(pos);
      });
      listener = new window.keypress.Listener();
      listener.simple_combo("a", function() {
        return world.player1Press();
      });
      listener.simple_combo("k", function() {
        return world.player2Press();
      });
    }

    return EventHandler;

  })();

  WIDTH = 1600.0;

  HEIGHT = 800.0;

  OFFSET = 150;

  getRatio = function() {
    var h, height, ratio, ratioh, ratiow, w, width;
    width = WIDTH;
    height = HEIGHT;
    w = window.innerWidth;
    h = window.innerHeight - OFFSET;
    ratiow = w / width;
    ratioh = h / height;
    if (ratiow < ratioh) {
      ratio = ratiow;
    } else {
      ratio = ratioh;
    }
    return ratio;
  };

  setRatio = function(width, height) {
    var c, ratio, ratioh, ratiow;
    c = document.getElementById("chess-board");
    c.width = window.innerWidth;
    c.height = window.innerHeight - OFFSET;
    ratiow = c.width / width;
    ratioh = c.height / height;
    if (ratiow < ratioh) {
      ratio = ratiow;
      c.height = height * ratio;
    } else {
      ratio = ratioh;
      c.width = width * ratio;
    }
    return ratio;
  };

  getCanvas = function() {
    var c, ctx, height, ratio, width;
    width = WIDTH;
    height = HEIGHT;
    c = document.getElementById("chess-board");
    ctx = c.getContext("2d");
    ratio = setRatio(width, height);
    ctx.scale(ratio, ratio);
    return new Canvas(ctx, width, height);
  };

  emit = function(msg) {
    return console.log(msg);
  };

  main = function() {
    var canvas, parser, status_bar, world;
    canvas = getCanvas();
    status_bar = new StatusBar;
    world = new World(canvas, status_bar);
    parser = new Parser(world, status_bar);
    parser.parse("xxx");
    return setInterval(function() {
      return world.render();
    });
  };

  $(function() {
    return main();
  });

  Parser = (function() {
    var STATE_BOARD_UPDATED, STATE_GAMEOVER_FOR_WATCHER, STATE_GAMEOVER_LOSE, STATE_GAMEOVER_WIN, STATE_ILLEGAL_OPERATION, STATE_OPPOENENT_ABORT, STATE_OPPOENENT_GIVEUP, STATE_READY, STATE_WAIT;

    STATE_WAIT = 0;

    STATE_READY = 1;

    STATE_ILLEGAL_OPERATION = 2;

    STATE_BOARD_UPDATED = 3;

    STATE_OPPOENENT_ABORT = 4;

    STATE_OPPOENENT_GIVEUP = 5;

    STATE_GAMEOVER_WIN = 6;

    STATE_GAMEOVER_LOSE = 7;

    STATE_GAMEOVER_FOR_WATCHER = 8;

    function Parser(world, status_bar) {
      this.world = world;
      this.status_bar = status_bar;
    }

    Parser.prototype.parse = function(data) {
      var game_state;
      game_state = {
        state: STATE_READY
      };
      console.log("a");
      console.log("b");
      console.log(game_state);
      if (game_state.state === STATE_WAIT) {
        this.status_bar.render("waiting for another player, copy url and invite your firend to play", "warning");
        this.world.render();
        return;
      }
      if (game_state.state === STATE_READY) {
        this.status_bar.render("opponent found, game start!", "info");
        this.world.init_units(game_state.boardInfo);
        this.world.render();
        return;
      }
      if (game_state.state === STATE_BOARD_UPDATED) {
        this.world.init_units(game_state.boardInfo);
        this.world.render();
        if (game_state.boardInfo.movable) {
          this.status_bar.render("opponent moved, your turn now", "info");
        } else {
          this.status_bar.render("you've moved, waiting opponent's move", "info");
        }
        return;
      }
      if (game_state.state === STATE_OPPOENENT_ABORT) {
        this.status_bar.render("opponent leave suddenly, waiting for another player...", "warning");
        return;
      }
      if (game_state.state === STATE_GAMEOVER_WIN) {
        this.world.init_units(game_state.boardInfo);
        this.world.render();
        this.status_bar.render("congraturations, you win!", "success");
        return;
      }
      if (game_state.state === STATE_GAMEOVER_LOSE) {
        this.world.init_units(game_state.boardInfo);
        this.world.render();
        this.status_bar.render("oh, you lose...", "danger");
      }
    };

    return Parser;

  })();

  StatusBar = (function() {
    function StatusBar() {}

    StatusBar.prototype.clear_class = function() {
      $("#status-bar").removeClass("alert-info");
      $("#status-bar").removeClass("alert-success");
      $("#status-bar").removeClass("alert-warning");
      return $("#status-bar").removeClass("alert-danger");
    };

    StatusBar.prototype.render = function(text, klass) {
      this.clear_class();
      $("#status-bar").addClass("alert-" + klass);
      return $("#status-bar").html(text);
    };

    return StatusBar;

  })();

  Unit = (function() {
    var COLOR_CIRCLE, COLOR_UNIT_BLACK, COLOR_UNIT_GREEN, COLOR_UNIT_RED, COLOR_UNIT_WHITE;

    COLOR_CIRCLE = 'RGB(244, 122, 2)';

    COLOR_UNIT_BLACK = 'RGB(0, 0, 0)';

    COLOR_UNIT_WHITE = 'RGB(255, 255, 255)';

    COLOR_UNIT_GREEN = 'RGB(0, 255, 0)';

    COLOR_UNIT_RED = 'RGB(255, 0, 0)';

    function Unit(board, side, value, pos) {
      this.board = board;
      this.side = side;
      this.value = value;
      this.pos = pos;
    }

    Unit.prototype.hight_light = function(canvas) {
      var point, r;
      point = this.board.position2point(this.pos);
      r = this.board.radius();
      if (this.side === 1) {
        canvas.fillCircle(COLOR_UNIT_GREEN, point.x, point.y, r);
        return canvas.drawText(COLOR_UNIT_WHITE, "80px Arial", this.value, point.x, point.y + 30);
      } else {
        canvas.fillCircle(COLOR_UNIT_RED, point.x, point.y, r);
        return canvas.drawText(COLOR_UNIT_BLACK, "80px Arial", this.value, point.x, point.y + 30);
      }
    };

    Unit.prototype.render = function(canvas) {
      var point, r;
      point = this.board.position2point(this.pos);
      r = this.board.radius();
      if (this.side === 1) {
        canvas.drawCircle(COLOR_CIRCLE, point.x, point.y, r);
        canvas.fillCircle(COLOR_UNIT_BLACK, point.x, point.y, r);
        return canvas.drawText(COLOR_UNIT_WHITE, "80px Arial", this.value, point.x, point.y + 30);
      } else {
        canvas.drawCircle(COLOR_CIRCLE, point.x, point.y, r);
        return canvas.drawText(COLOR_UNIT_BLACK, "80px Arial", this.value, point.x, point.y + 30);
      }
    };

    return Unit;

  })();

  Wall = (function() {
    var COLOR_WALL;

    COLOR_WALL = 'RGB(100, 0, 240)';

    function Wall(height, width) {
      this.height = height;
      this.width = width;
    }

    Wall.prototype.render = function(canvas) {
      canvas.drawLine(COLOR_WALL, -this.width, -this.height / 2, -this.width, this.height / 2);
      return canvas.drawLine(COLOR_WALL, this.width, -this.height / 2, this.width, this.height / 2);
    };

    return Wall;

  })();

  Websocket = (function() {
    var WS_HOST;

    WS_HOST = "ws://localhost:3000";

    function Websocket(parser) {
      this.set_slug_and_url();
      this.ws_conn = null;
      this.parser = parser;
    }

    Websocket.prototype.random_slug = function() {
      return (Math.floor(Math.random() * 1000) + 1000).toString();
    };

    Websocket.prototype.set_slug_and_url = function() {
      var array, currentUrl;
      currentUrl = window.location.href;
      array = currentUrl.split("?room=");
      if (array.length < 2) {
        this.slug = this.random_slug();
        currentUrl += "?room=" + this.slug;
      } else {
        this.slug = array[1];
      }
      return window.history.pushState({}, 0, currentUrl);
    };

    Websocket.prototype.connect = function() {
      var self, _action, _parser, _reconnect;
      if (this.ws_conn !== null) {
        return;
      }
      console.log("connected");
      _parser = this.parser;
      _reconnect = this.reconnect;
      self = this;
      _action = function() {
        self.ws_conn = null;
        return self.connect();
      };
      this.ws_conn = new WebSocket(WS_HOST + "/ws/" + this.slug);
      this.ws_conn.onopen = function(data) {
        return console.log(data);
      };
      this.ws_conn.onmessage = function(msg_event) {
        var data;
        data = msg_event.data;
        return _parser.parse(data);
      };
      this.ws_conn.onclose = function(data) {
        return alert("close");
      };
      return this.ws_conn.onerror = function(data) {
        return alert("error");
      };
    };

    Websocket.prototype.reconnect_action = function() {
      this.ws_conn = null;
      return this.connect();
    };

    Websocket.prototype.reconnect = function(action) {
      return setTimeout(action, Math.floor(Math.random() * 5001) + 1000);
    };

    Websocket.prototype.send = function(data) {
      return this.ws_conn.send(data);
    };

    return Websocket;

  })();

  World = (function() {
    var ARROW_SIDE_LEFT, ARROW_SIDE_RIGHT, BREAK_HEIGH, BREAK_WIDTH;

    BREAK_WIDTH = 150;

    BREAK_HEIGH = 100;

    ARROW_SIDE_LEFT = 0;

    ARROW_SIDE_RIGHT = 1;

    function World(canvas, bar) {
      this.canvas = canvas;
      this.bar = bar;
      this.objects = [];
      this.board = new BackGround(6);
      this.units = [];
      this.attack_points = [];
      this.ws = null;
      this["break"] = new Break(BREAK_HEIGH, this, BREAK_WIDTH, 0);
      this.break1 = new Break(BREAK_HEIGH, this, BREAK_WIDTH, 200);
      this.break2 = new Break(BREAK_HEIGH, this, BREAK_WIDTH, -200);
      this.width = 800;
      this.hieght = 400;
      this.arrow1 = new Arrow(ARROW_SIDE_LEFT, this);
      this.arrow2 = new Arrow(ARROW_SIDE_RIGHT, this);
      new EventHandler(this);
    }

    World.prototype.attackable = function(position) {
      if (position > 200 - BREAK_HEIGH / 2 && position < 200 + BREAK_HEIGH / 2) {
        return true;
      }
      if (position > -200 - BREAK_HEIGH / 2 && position < -200 + BREAK_HEIGH / 2) {
        return true;
      }
      if (position > 0 - BREAK_HEIGH / 2 && position < 0 + BREAK_HEIGH / 2) {
        return true;
      }
      return false;
    };

    World.prototype.attackable_index = function(arrow) {
      var position, w;
      position = arrow.get_position();
      w = arrow.get_half_heigh();
      w = 0;
      if (position > -200 - BREAK_HEIGH / 2 + w && position < -200 + BREAK_HEIGH / 2 - w) {
        return 1;
      }
      if (position > 0 - BREAK_HEIGH / 2 + w && position < 0 + BREAK_HEIGH / 2 - w) {
        return 2;
      }
      if (position > 200 - BREAK_HEIGH / 2 + w && position < 200 + BREAK_HEIGH / 2 - w) {
        return 3;
      }
      return 0;
    };

    World.prototype.break_offset = function(index) {
      if (index === 1) {
        return this.break2.get_offset();
      }
      if (index === 2) {
        return this["break"].get_offset();
      }
      if (index === 3) {
        return this.break1.get_offset();
      }
    };

    World.prototype.move_break = function(index, side) {
      if (index === 1) {
        return this.break2.move(side);
      }
      if (index === 2) {
        return this["break"].move(side);
      }
      if (index === 3) {
        return this.break1.move(side);
      }
    };

    World.prototype.gameover = function(side) {
      var msg;
      this.arrow1.stop();
      this.arrow2.stop();
      msg = "left win!";
      if (side === 0) {
        msg = "left win!";
      } else if (side === 1) {
        msg = "right win!";
      }
      return this.bar.render(msg, "success");
    };

    World.prototype.half_width = function() {
      return 800;
    };

    World.prototype.half_height = function() {
      return 400;
    };

    World.prototype.init_units = function(board_info) {
      var unit, _i, _len, _ref, _results;
      this.units = [];
      return;
      this.movable = board_info.movable;
      this.my_side = board_info.side;
      _ref = board_info.Units;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        _results.push(this.units.push(new Unit(this.board, unit.side, unit.value, {
          x: unit.pos.x,
          y: unit.pos.y
        })));
      }
      return _results;
    };

    World.prototype.hover = function(pos) {
      console.log("h");
    };

    World.prototype.select = function(pos) {
      console.log("pos");
    };

    World.prototype.in_my_side = function(pos) {
      var unit, _i, _len, _ref;
      _ref = this.units;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        if (unit.pos.x === pos.x && unit.pos.y === pos.y && unit.side === this.my_side && this.movable) {
          return true;
        }
      }
      return false;
    };

    World.prototype.player1Press = function() {
      return this.arrow1.shoot();
    };

    World.prototype.player2Press = function() {
      return this.arrow2.shoot();
    };

    World.prototype.render = function() {
      this.canvas.clear();
      this.board.render(this.canvas);
      this["break"].render(this.canvas);
      this.break1.render(this.canvas);
      this.break2.render(this.canvas);
      this.arrow1.render(this.canvas);
      return this.arrow2.render(this.canvas);
    };

    return World;

  })();

}).call(this);

/*
//@ sourceMappingURL=app.map
*/
