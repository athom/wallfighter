// Generated by CoffeeScript 1.6.3
(function() {
  var Arrow, BackGround, Border, Break, Canvas, Connector, EventHandler, HEIGHT, OFFSET, StatusBar, WIDTH, Wall, Websocket, World, getCanvas, getRatio, main, setRatio;

  Arrow = (function() {
    var COLOR_ARROW, CYCLE_COUNT, HEIGHT, OFFSET, SIDE_LEFT, SIDE_RIGHT, V_FAST, V_MIDDLE, V_SLOW, WIDTH;

    COLOR_ARROW = 'RGBA(464, 224, 126, 0.7)';

    WIDTH = 200;

    HEIGHT = 20;

    SIDE_LEFT = 0;

    SIDE_RIGHT = 1;

    OFFSET = 500;

    V_SLOW = 5;

    V_MIDDLE = 5;

    V_FAST = 5;

    CYCLE_COUNT = 800;

    function Arrow(side, world) {
      this.side = side;
      this.world = world;
      this.position = 0;
      this.v = V_MIDDLE;
      this.cycle = 0;
      this.offset = 0;
      this.is_shooting = false;
      this.is_shooting_back = false;
      this.protecting_section_index = 0;
    }

    Arrow.prototype.get_offset = function() {
      if (this.side === SIDE_LEFT) {
        return this.offset - OFFSET;
      }
      if (this.side === SIDE_RIGHT) {
        return this.offset + OFFSET;
      }
    };

    Arrow.prototype.set_position = function(position) {
      return this.position = position;
    };

    Arrow.prototype.get_position = function() {
      return this.position;
    };

    Arrow.prototype.get_direction = function() {
      var v;
      v = Math.abs(this.v);
      return this.v / v;
    };

    Arrow.prototype.get_half_heigh = function() {
      return HEIGHT / 2;
    };

    Arrow.prototype.shoot = function(pos) {
      var index;
      index = this.world.attackable_index(this);
      if (index !== 0 && index === this.protecting_section_index) {
        return;
      }
      return this.is_shooting = true;
    };

    Arrow.prototype.sync = function(pos) {
      return this.set_position(pos);
    };

    Arrow.prototype.next_velocity = function() {
      var sign, v;
      v = Math.abs(this.v);
      sign = this.v / v;
      if (v === V_MIDDLE) {
        return sign * V_FAST;
      }
      if (v === V_FAST) {
        return sign * V_SLOW;
      }
      if (v === V_SLOW) {
        return sign * V_MIDDLE;
      }
    };

    Arrow.prototype.is_hit = function() {
      var d, index, offset;
      offset = 0;
      index = this.world.attackable_index(this);
      if (index !== 0) {
        offset = this.world.break_offset(index);
      }
      if (this.side === SIDE_RIGHT) {
        offset = -offset;
      }
      d = offset + this.world.half_width() - 2 * WIDTH - 150;
      if (this.side === SIDE_LEFT) {
        return this.offset >= d;
      }
      if (this.side === SIDE_RIGHT) {
        return this.offset <= -d;
      }
    };

    Arrow.prototype.shoot_forward = function() {
      var index, offset, pos, v;
      pos = this.get_position();
      this.world.syncPosition(pos);
      v = Math.abs(this.v);
      if (this.side === SIDE_RIGHT) {
        v = -v;
      }
      this.offset += v;
      if (this.is_hit()) {
        this.is_shooting_back = true;
        index = this.world.attackable_index(this);
        if (index !== 0) {
          return offset = this.world.move_break(index, this.side);
        }
      }
    };

    Arrow.prototype.stop = function() {
      return this.halt = true;
    };

    Arrow.prototype.start = function() {
      return this.halt = false;
    };

    Arrow.prototype.shoot_back = function() {
      var v;
      v = Math.abs(this.v);
      if (this.side === SIDE_LEFT) {
        v = -v;
      }
      this.offset += v;
      if (this.offset <= 0 && this.side === SIDE_LEFT || this.offset >= 0 && this.side === SIDE_RIGHT) {
        this.is_shooting_back = false;
        this.is_shooting = false;
        return this.protecting_section_index = this.world.attackable_index(this);
      }
    };

    Arrow.prototype.roaming = function() {
      var h;
      if (this.halt) {
        return;
      }
      if (this.world.attackable_index(this) === 0) {
        this.protecting_section_index = 0;
      }
      this.position += this.v;
      h = this.world.half_height();
      if (this.position >= h) {
        this.v = -this.v;
      }
      if (this.position <= -h) {
        return this.v = -this.v;
      }
    };

    Arrow.prototype.on_velocity_change = function() {
      this.cycle += 1;
      if (this.cycle === CYCLE_COUNT) {
        this.v = this.next_velocity();
        return this.cycle = 0;
      }
    };

    Arrow.prototype.run = function() {
      if (this.is_shooting_back) {
        this.shoot_back();
      } else if (this.is_shooting) {
        this.shoot_forward();
      } else {
        this.roaming();
      }
      return this.on_velocity_change();
    };

    Arrow.prototype.render = function(canvas) {
      var offset;
      this.run();
      offset = this.get_offset();
      return canvas.fillRect(COLOR_ARROW, {
        x: offset - WIDTH / 2,
        y: this.position - HEIGHT / 2,
        w: WIDTH,
        h: HEIGHT
      });
    };

    return Arrow;

  })();

  BackGround = (function() {
    var COLOR_ATTACK, COLOR_BORDER, COLOR_LINE, HEIGHT, WALL_WIDTH, WIDTH;

    WIDTH = 1600;

    HEIGHT = 800;

    WALL_WIDTH = 150;

    COLOR_BORDER = 'RGB(100, 0, 240)';

    COLOR_LINE = 'RGB(100, 0, 240)';

    COLOR_ATTACK = 'RGBA(264, 224, 126, 0.4)';

    function BackGround(size) {
      this.size = size;
      this.border = new Border;
      this.wall = new Wall(HEIGHT, WALL_WIDTH);
    }

    BackGround.prototype.render = function(canvas) {
      var heightUnit, i, widthUnit, x1, y1, _i, _ref, _results;
      this.border.render(canvas);
      this.wall.render(canvas);
      return;
      widthUnit = WIDTH / this.size;
      heightUnit = HEIGHT / this.size;
      _results = [];
      for (i = _i = 1, _ref = this.size; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        i = i - this.size / 2;
        x1 = i * widthUnit;
        y1 = i * heightUnit;
        canvas.drawLine(COLOR_BORDER, x1, -HEIGHT / 2, x1, HEIGHT / 2);
        _results.push(canvas.drawLine(COLOR_BORDER, -HEIGHT / 2, y1, HEIGHT / 2, y1));
      }
      return _results;
    };

    return BackGround;

  })();

  Border = (function() {
    var COLOR_ATTACK, COLOR_BORDER, COLOR_LINE, HEIGHT, WIDTH;

    WIDTH = 1600;

    HEIGHT = 800;

    COLOR_BORDER = 'RGB(100, 0, 240)';

    COLOR_LINE = 'RGB(100, 0, 240)';

    COLOR_ATTACK = 'RGBA(264, 224, 126, 0.4)';

    function Border() {}

    Border.prototype.render = function(canvas) {
      return canvas.drawRect(COLOR_BORDER, {
        x: -WIDTH / 2,
        y: -HEIGHT / 2,
        w: WIDTH,
        h: HEIGHT
      });
    };

    return Border;

  })();

  Break = (function() {
    var COLOR_BREAK, DANGER_LEFT, DANGER_LEFT_2, DANGER_LEFT_3, DANGER_MIDDLE, DANGER_RIGHT, DANGER_RIGHT_2, DANGER_RIGHT_3, PUSH_FROM_LEFT, PUSH_FROM_RIGHT;

    COLOR_BREAK = 'RGB(100, 250, 240)';

    PUSH_FROM_LEFT = 0;

    PUSH_FROM_RIGHT = 1;

    DANGER_MIDDLE = 0;

    DANGER_LEFT = -1;

    DANGER_LEFT_2 = -2;

    DANGER_LEFT_3 = -3;

    DANGER_RIGHT = 1;

    DANGER_RIGHT_2 = 2;

    DANGER_RIGHT_3 = 3;

    function Break(height, world, width, position) {
      this.world = world;
      this.height = height;
      this.width = width;
      this.position = position;
      this.danger = DANGER_MIDDLE;
      this.is_falling = false;
    }

    Break.prototype.get_offset = function() {
      var delta;
      delta = 2 * this.width / 3;
      if (this.danger === DANGER_MIDDLE) {
        return 0;
      }
      if (this.danger === DANGER_LEFT) {
        return -1 * delta;
      }
      if (this.danger === DANGER_LEFT_2) {
        return -2 * delta;
      }
      if (this.danger === DANGER_LEFT_3) {
        return -3 * delta;
      }
      if (this.danger === DANGER_RIGHT) {
        return 1 * delta;
      }
      if (this.danger === DANGER_RIGHT_2) {
        return 2 * delta;
      }
      if (this.danger === DANGER_RIGHT_3) {
        return 3 * delta;
      }
    };

    Break.prototype.move = function(side) {
      if (side === PUSH_FROM_LEFT) {
        this.danger += 1;
      } else if (side === PUSH_FROM_RIGHT) {
        this.danger -= 1;
      }
      if (this.danger === DANGER_LEFT_3) {
        this.is_falling = true;
        return this.world.gameover(PUSH_FROM_RIGHT);
      } else if (this.danger === DANGER_RIGHT_3) {
        this.is_falling = true;
        return this.world.gameover(PUSH_FROM_LEFT);
      }
    };

    Break.prototype.render = function(canvas) {
      var field, offset;
      if (this.is_falling) {
        if (this.danger === DANGER_LEFT_3 || this.danger === DANGER_RIGHT_3) {
          this.position += 5;
        }
        if (this.position >= this.world.half_height() - 50) {
          this.is_falling = false;
        }
      }
      offset = this.get_offset();
      field = {
        x: offset - this.width,
        y: this.position - this.height / 2,
        w: this.width * 2,
        h: this.height
      };
      return canvas.fillRect(COLOR_BREAK, field);
    };

    return Break;

  })();

  Canvas = function(ctx, w, h) {
    this.ctx = ctx;
    this.w = w;
    return this.h = h;
  };

  Canvas.prototype.fillRect = function(color, rect) {
    this.ctx.fillStyle = color;
    return this.ctx.fillRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawRect = function(color, rect) {
    this.ctx.strokeStyle = color;
    return this.ctx.strokeRect(this.xscreen(rect.x), this.yscreen(rect.y), rect.w, rect.h);
  };

  Canvas.prototype.drawLine = function(color, sx, sy, ex, ey) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(this.xscreen(sx), this.yscreen(sy));
    this.ctx.lineTo(this.xscreen(ex), this.yscreen(ey));
    return this.ctx.stroke();
  };

  Canvas.prototype.drawArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.strokeStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.stroke();
  };

  Canvas.prototype.fillArc = function(color, x, y, r, sAngle, eAngle) {
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(this.xscreen(x), this.yscreen(y), r, sAngle, eAngle);
    return this.ctx.fill();
  };

  Canvas.prototype.drawCircle = function(color, x, y, r) {
    return this.drawArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.fillCircle = function(color, x, y, r) {
    return this.fillArc(color, x, y, r, 0, 2 * Math.PI);
  };

  Canvas.prototype.drawText = function(color, font, text, x, y) {
    this.ctx.fillStyle = color;
    this.ctx.font = font;
    x = x - this.ctx.measureText(text).width / 2;
    return this.ctx.fillText(text, this.xscreen(x), this.yscreen(y));
  };

  Canvas.prototype.clear = function() {
    return this.ctx.clearRect(0, 0, this.w, this.h);
  };

  Canvas.prototype.xscreen = function(x) {
    return x + this.w / 2;
  };

  Canvas.prototype.yscreen = function(y) {
    return y + this.h / 2;
  };

  Connector = (function() {
    function Connector(bar) {
      this.bar = bar;
      this.ping_token = Math.random().toString(36).substr(2);
      this.room_token = "";
      this.mathing = false;
      this.yunba_init();
    }

    Connector.prototype.set_world = function(w) {
      return this.world = w;
    };

    Connector.prototype.yunba_init = function() {
      var _this = this;
      this.yunba = new Yunba({
        appkey: '52fcc04c4dc903d66d6f8f92'
      });
      this.yunba.init(function(success) {
        if (success) {
          return _this.connecting();
        } else {
          return _this.bar.show_tip("server init failed", "danger");
        }
      });
      return this.yunba.set_message_cb(function(data) {
        return _this._on_msg_incoming(data);
      });
    };

    Connector.prototype.connecting = function() {
      var _this = this;
      return this.yunba.connect(function(success, msg) {
        if (success) {
          return _this.on_connected();
        } else {
          return _this.bar.show_tip("connecting server failed", "danger");
        }
      });
    };

    Connector.prototype.on_connected = function() {
      console.log("Yahoo 2!");
      this.bar.show_tip("已经连接服务器,正在匹配另一个玩家", "info");
      this.subscribe("all");
      this.subscribe(this.ping_token);
      return this._send_msg("all", this.ping_token);
    };

    Connector.prototype.subscribe = function(topic) {
      var _this = this;
      return this.yunba.subscribe({
        'topic': topic
      }, function(success, msg) {
        if (success) {
          return console.log("subscribed ok");
        } else {
          return _this.bar.show_tip("subscribe topic (" + topic + ") failed", "danger");
        }
      });
    };

    Connector.prototype.do_unsubscribe = function(topic) {
      var _this = this;
      return this.yunba.unsubscribe({
        'topic': topic
      }, function(success, msg) {
        if (success) {
          return console.log("unsubscribed ok");
        } else {
          return _this.bar.show_tip("unsubscribe topic (" + topic + ") failed", "danger");
        }
      });
    };

    Connector.prototype.on_matched = function() {
      this.bar.show_tip("PK中...", "info");
      return this._send_msg(this.room_token, "start");
    };

    Connector.prototype.on_playing = function() {
      this.bar.show_tip("PK中...", "info");
      return this._send_msg(this.room_token, "start");
    };

    Connector.prototype.on_gameover = function() {};

    Connector.prototype.on_disconnected = function() {};

    Connector.prototype.singal_find_matcher = function() {};

    Connector.prototype.singal_find_matcher = function() {};

    Connector.prototype._on_msg_incoming = function(data) {
      console.log("incoming:");
      console.log(data);
      console.log("ping_token: " + this.ping_token);
      console.log("room_token: " + this.room_token);
      if (data.topic === "all") {
        return this.on_msg_all(data.msg);
      }
      if (this.room_token !== "" && data.topic === this.room_token) {
        if (data.msg === "ping") {
          return this.on_msg_mathing_ping();
        }
        if (data.msg === "pong") {
          return this.on_msg_mathing_pong();
        }
        if (data.msg === "start") {
          return this.on_msg_gaming_start();
        }
        if (!!data.msg.match(/sync:/)) {
          return this.on_msg_gaming_sync(data.msg);
        }
        return this.on_msg_gaming_shoot(data.msg);
      }
      if (data.topic === this.ping_token) {
        if (data.msg === "ping") {
          return this.on_msg_mathing_ping();
        }
      }
    };

    Connector.prototype.shoot = function(pos) {
      return this._send_msg(this.room_token, "shoot:" + this.ping_token + ":" + pos);
    };

    Connector.prototype.sync = function(pos) {
      return this._send_msg(this.room_token, "sync:" + this.ping_token + ":" + pos);
    };

    Connector.prototype._send_msg = function(topic, msg) {
      var _this = this;
      return this.yunba.publish({
        'topic': topic,
        'msg': msg
      }, function(success, msg) {
        if (success) {
          return console.log("sent " + msg);
        } else {
          return _this.bar.show_tip("sent msg (" + msg(") error", "danger"));
        }
      });
    };

    Connector.prototype.on_msg_all = function(msg) {
      if (msg === this.ping_token) {
        return;
      }
      if (this.mathing) {
        return;
      }
      this.mathing = true;
      this.room_token = msg;
      this.subscribe(this.room_token);
      this._send_msg(this.room_token, "ping");
      console.log("all incoming:");
      return console.log(msg);
    };

    Connector.prototype.on_msg_mathing_ping = function() {
      console.log("ping incoming:");
      if (this.room_token === "") {
        this.room_token = this.ping_token;
      }
      this._send_msg(this.room_token, "pong");
      this.do_unsubscribe("all");
      return this.on_matched();
    };

    Connector.prototype.on_msg_mathing_pong = function() {
      console.log("pong incoming:");
      this.do_unsubscribe("all");
      return this.on_matched();
    };

    Connector.prototype.on_msg_gaming_start = function() {
      return this.world.start_game();
    };

    Connector.prototype.on_msg_gaming_sync = function(msg) {
      var a, pos, shooter;
      a = msg.split(":");
      if (!a || a.length !== 3) {
        console.log("ERROR: shoot msg format failed");
        return;
      }
      shooter = a[1];
      shooter = a[1];
      pos = parseInt(a[2]);
      if (shooter === this.ping_token) {

      } else {
        return this.world.player2Sync(pos);
      }
    };

    Connector.prototype.on_msg_gaming_shoot = function(msg) {
      var a, pos, shooter;
      console.log("------------------------------------------------>");
      console.log(msg);
      a = msg.split(":");
      if (!a || a.length !== 3) {
        console.log("ERROR: shoot msg format failed");
        return;
      }
      shooter = a[1];
      pos = parseInt(a[2]);
      if (shooter === this.ping_token) {
        return this.world.player1Shoot(pos);
      } else {
        return this.world.player2Shoot(pos);
      }
    };

    return Connector;

  })();

  EventHandler = (function() {
    function EventHandler(world) {
      var listener;
      listener = new window.keypress.Listener();
      listener.simple_combo("space", function() {
        return world.player1Press();
      });
    }

    return EventHandler;

  })();

  WIDTH = 1600.0;

  HEIGHT = 800.0;

  OFFSET = 150;

  getRatio = function() {
    var h, height, ratio, ratioh, ratiow, w, width;
    width = WIDTH;
    height = HEIGHT;
    w = window.innerWidth;
    h = window.innerHeight - OFFSET;
    ratiow = w / width;
    ratioh = h / height;
    if (ratiow < ratioh) {
      ratio = ratiow;
    } else {
      ratio = ratioh;
    }
    return ratio;
  };

  setRatio = function(width, height) {
    var c, ratio, ratioh, ratiow;
    c = document.getElementById("chess-board");
    c.width = window.innerWidth;
    c.height = window.innerHeight - OFFSET;
    ratiow = c.width / width;
    ratioh = c.height / height;
    if (ratiow < ratioh) {
      ratio = ratiow;
      c.height = height * ratio;
    } else {
      ratio = ratioh;
      c.width = width * ratio;
    }
    return ratio;
  };

  getCanvas = function() {
    var c, ctx, height, ratio, width;
    width = WIDTH;
    height = HEIGHT;
    c = document.getElementById("chess-board");
    ctx = c.getContext("2d");
    ratio = setRatio(width, height);
    ctx.scale(ratio, ratio);
    return new Canvas(ctx, width, height);
  };

  main = function() {
    var canvas, connector, status_bar, world;
    canvas = getCanvas();
    status_bar = new StatusBar;
    connector = new Connector(status_bar);
    world = new World(canvas, status_bar, connector);
    return setInterval(function() {
      return world.render();
    });
  };

  $(function() {
    return main();
  });

  StatusBar = (function() {
    function StatusBar() {}

    StatusBar.prototype.clear_class = function() {
      $("#status-bar").removeClass("alert-info");
      $("#status-bar").removeClass("alert-success");
      $("#status-bar").removeClass("alert-warning");
      return $("#status-bar").removeClass("alert-danger");
    };

    StatusBar.prototype.show_tip = function(text, klass) {
      this.clear_class();
      $("#status-bar").addClass("alert-" + klass);
      return $("#status-bar").html(text);
    };

    return StatusBar;

  })();

  Wall = (function() {
    var COLOR_WALL;

    COLOR_WALL = 'RGB(100, 0, 240)';

    function Wall(height, width) {
      this.height = height;
      this.width = width;
    }

    Wall.prototype.render = function(canvas) {
      canvas.drawLine(COLOR_WALL, -this.width, -this.height / 2, -this.width, this.height / 2);
      return canvas.drawLine(COLOR_WALL, this.width, -this.height / 2, this.width, this.height / 2);
    };

    return Wall;

  })();

  Websocket = (function() {
    var WS_HOST;

    WS_HOST = "ws://localhost:3000";

    function Websocket(parser) {
      this.set_slug_and_url();
      this.ws_conn = null;
      this.parser = parser;
    }

    Websocket.prototype.random_slug = function() {
      return (Math.floor(Math.random() * 1000) + 1000).toString();
    };

    Websocket.prototype.set_slug_and_url = function() {
      var array, currentUrl;
      currentUrl = window.location.href;
      array = currentUrl.split("?room=");
      if (array.length < 2) {
        this.slug = this.random_slug();
        currentUrl += "?room=" + this.slug;
      } else {
        this.slug = array[1];
      }
      return window.history.pushState({}, 0, currentUrl);
    };

    Websocket.prototype.connect = function() {
      var self, _action, _parser, _reconnect;
      if (this.ws_conn !== null) {
        return;
      }
      console.log("connected");
      _parser = this.parser;
      _reconnect = this.reconnect;
      self = this;
      _action = function() {
        self.ws_conn = null;
        return self.connect();
      };
      this.ws_conn = new WebSocket(WS_HOST + "/ws/" + this.slug);
      this.ws_conn.onopen = function(data) {
        return console.log(data);
      };
      this.ws_conn.onmessage = function(msg_event) {
        var data;
        data = msg_event.data;
        return _parser.parse(data);
      };
      this.ws_conn.onclose = function(data) {
        return alert("close");
      };
      return this.ws_conn.onerror = function(data) {
        return alert("error");
      };
    };

    Websocket.prototype.reconnect_action = function() {
      this.ws_conn = null;
      return this.connect();
    };

    Websocket.prototype.reconnect = function(action) {
      return setTimeout(action, Math.floor(Math.random() * 5001) + 1000);
    };

    Websocket.prototype.send = function(data) {
      return this.ws_conn.send(data);
    };

    return Websocket;

  })();

  World = (function() {
    var ARROW_SIDE_LEFT, ARROW_SIDE_RIGHT, BREAK_HEIGH, BREAK_WIDTH;

    BREAK_WIDTH = 150;

    BREAK_HEIGH = 100;

    ARROW_SIDE_LEFT = 0;

    ARROW_SIDE_RIGHT = 1;

    function World(canvas, bar, connector) {
      this.canvas = canvas;
      this.bar = bar;
      this.connector = connector;
      this.connector.set_world(this);
      this.objects = [];
      this.bg = new BackGround(6);
      this.units = [];
      this.attack_points = [];
      this.ws = null;
      this["break"] = new Break(BREAK_HEIGH, this, BREAK_WIDTH, 0);
      this.break1 = new Break(BREAK_HEIGH, this, BREAK_WIDTH, 200);
      this.break2 = new Break(BREAK_HEIGH, this, BREAK_WIDTH, -200);
      this.width = 800;
      this.hieght = 400;
      this.arrow1 = new Arrow(ARROW_SIDE_LEFT, this);
      this.arrow2 = new Arrow(ARROW_SIDE_RIGHT, this);
      this.arrow1.stop();
      this.arrow2.stop();
      new EventHandler(this);
    }

    World.prototype.attackable = function(position) {
      if (position > 200 - BREAK_HEIGH / 2 && position < 200 + BREAK_HEIGH / 2) {
        return true;
      }
      if (position > -200 - BREAK_HEIGH / 2 && position < -200 + BREAK_HEIGH / 2) {
        return true;
      }
      if (position > 0 - BREAK_HEIGH / 2 && position < 0 + BREAK_HEIGH / 2) {
        return true;
      }
      return false;
    };

    World.prototype.attackable_index = function(arrow) {
      var position, w;
      position = arrow.get_position();
      w = arrow.get_half_heigh();
      w = 0;
      if (position > -200 - BREAK_HEIGH / 2 + w && position < -200 + BREAK_HEIGH / 2 - w) {
        return 1;
      }
      if (position > 0 - BREAK_HEIGH / 2 + w && position < 0 + BREAK_HEIGH / 2 - w) {
        return 2;
      }
      if (position > 200 - BREAK_HEIGH / 2 + w && position < 200 + BREAK_HEIGH / 2 - w) {
        return 3;
      }
      return 0;
    };

    World.prototype.break_offset = function(index) {
      if (index === 1) {
        return this.break2.get_offset();
      }
      if (index === 2) {
        return this["break"].get_offset();
      }
      if (index === 3) {
        return this.break1.get_offset();
      }
    };

    World.prototype.move_break = function(index, side) {
      if (index === 1) {
        return this.break2.move(side);
      }
      if (index === 2) {
        return this["break"].move(side);
      }
      if (index === 3) {
        return this.break1.move(side);
      }
    };

    World.prototype.gameover = function(side) {
      var msg;
      this.arrow1.stop();
      this.arrow2.stop();
      msg = "left win!";
      if (side === 0) {
        msg = "left win!";
      } else if (side === 1) {
        msg = "right win!";
      }
      return this.bar.render(msg, "success");
    };

    World.prototype.half_width = function() {
      return 800;
    };

    World.prototype.half_height = function() {
      return 400;
    };

    World.prototype.hover = function(pos) {};

    World.prototype.select = function(pos) {
      console.log("pos");
    };

    World.prototype.in_my_side = function(pos) {
      var unit, _i, _len, _ref;
      _ref = this.units;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        if (unit.pos.x === pos.x && unit.pos.y === pos.y && unit.side === this.my_side && this.movable) {
          return true;
        }
      }
      return false;
    };

    World.prototype.player1Press = function() {
      var position;
      position = this.arrow1.get_position();
      return this.connector.shoot(position);
    };

    World.prototype.syncPosition = function(pos) {
      return this.connector.sync(pos);
    };

    World.prototype.player2Press = function() {};

    World.prototype.player1Shoot = function(pos) {
      return this.arrow1.shoot(pos);
    };

    World.prototype.player2Shoot = function(pos) {
      return this.arrow2.shoot(pos);
    };

    World.prototype.player2Sync = function(pos) {
      console.log("sync@@@@@@@@@@" + pos);
      return this.arrow2.sync(pos);
    };

    World.prototype.start_game = function() {
      this.arrow1.start();
      return this.arrow2.start();
    };

    World.prototype.render = function() {
      this.canvas.clear();
      this.bg.render(this.canvas);
      this["break"].render(this.canvas);
      this.break1.render(this.canvas);
      this.break2.render(this.canvas);
      this.arrow1.render(this.canvas);
      return this.arrow2.render(this.canvas);
    };

    return World;

  })();

}).call(this);

/*
//@ sourceMappingURL=app.map
*/
